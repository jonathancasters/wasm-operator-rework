use serde::{Deserialize, Serialize};

// Use the modules generated by wit_bindgen
use crate::local::operator::kubernetes;
use crate::local::operator::types;
use crate::wasi::cli::environment;

wit_bindgen::generate!(
    {
        path: "../../../parent/wit",
        world: "child-world",
    }
);

// Structs for parsing the TestResource JSON
#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct TestResource {
    api_version: String,
    kind: String,
    metadata: ObjectMeta,
    spec: Spec,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct ObjectMeta {
    name: String,
    namespace: String,
}

#[derive(Serialize, Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct Spec {
    nonce: String,
}

struct Operator;

impl Guest for Operator {
    fn get_watch_requests() -> Vec<types::WatchRequest> {
        let ns = match environment::get_environment()
            .iter()
            .find(|(k, _)| k == "WATCH_NAMESPACE")
        {
            Some((_, v)) => v.clone(),
            None => {
                kubernetes::log(types::LogLevel::Error, "WATCH_NAMESPACE environment variable not set");
                return vec![];
            }
        };

        vec![types::WatchRequest {
            kind: "TestResource".to_string(),
            namespace: ns,
        }]
    }

    fn reconcile(req: types::ReconcileRequest) -> types::ReconcileResult {
        // 1. Get ACTION_NAMESPACE from environment
        let action_ns = match environment::get_environment()
            .iter()
            .find(|(k, _)| k == "ACTION_NAMESPACE")
        {
            Some((_, v)) => v.clone(),
            None => {
                let msg = "ACTION_NAMESPACE environment variable not set";
                kubernetes::log(types::LogLevel::Error, msg);
                return types::ReconcileResult::Error(msg.to_string());
            }
        };

        // 2. Parse the incoming resource
        let resource: TestResource = match serde_json::from_str(&req.resource_json) {
            Ok(r) => r,
            Err(e) => {
                let msg = format!("Error parsing resource JSON: {}", e);
                kubernetes::log(types::LogLevel::Error, &msg);
                return types::ReconcileResult::Error(msg);
            }
        };

        // 3. Construct the resource to be applied in the action namespace
        //    The host will use a server-side apply, which handles both creation and updates.
        let resource_to_apply = TestResource {
            api_version: resource.api_version.clone(),
            kind: resource.kind.clone(),
            metadata: ObjectMeta {
                name: resource.metadata.name.clone(),
                namespace: action_ns.clone(),
            },
            spec: resource.spec,
        };

        let apply_json = match serde_json::to_string(&resource_to_apply) {
            Ok(j) => j,
            Err(e) => {
                let msg = format!("Error marshalling resource to JSON: {}", e);
                kubernetes::log(types::LogLevel::Error, &msg);
                return types::ReconcileResult::Error(msg);
            }
        };

        // 4. Call UpdateResource to perform a server-side apply.
        if let Err(e) = kubernetes::update_resource("TestResource", &resource.metadata.name, &action_ns, &apply_json) {
            let msg = format!("Error upserting resource: {}", e);
            kubernetes::log(types::LogLevel::Error, &msg);
            return types::ReconcileResult::Error(msg);
        }

        types::ReconcileResult::Ok
    }

    fn serialize() -> Vec<u8> {
        Vec::new()
    }

    fn deserialize(_bytes: Vec<u8>) {}
}

export!(Operator);
